# 1. 常用算法

## 1.1 双指针 (快慢指针)

- #### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

## 1.2 动态规划

## 1.3 贪心算法

## 1.4 并查集

## 1.5 DFS 与 BFS

## 1.6 前缀和

# 2.常用技巧

## 2.1 集合数组等

### 2.11 数组转换为list和set：

```java
List<Integer> arrayList = new ArrayList<>();
Collections.addAll(arrayList, array);
arrayList.add(0);
System.out.println(arrayList);

// Set 不能实例化，
Set<Integer> set = new HashSet<>(arrayList);
System.out.println(set);
```

### 2.12 list和set如何转换成数组呢

### 2.13 list和set如何深浅拷贝呢？

## 2.2 排序方法

<u>**重要：数组排序的方法**</u>

1. `Arrays.sort(int[] a) // 对一个数组的所有元素进行排序，并且是按从小到大的顺序`

2. `Arrays.sort(int[] a, int fromIndex, int toIndex)设置了范围，toIndex不参与`

3. 自己设置排序的方法，实现Comparator

   ```java
   public class ArraySort {
       public static void main(String[] args) {
           //注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）
           //而要使用它们对应的类
           Integer[] a = {9, 8, 7, 2, 3, 4, 1, 0, 6, 5};
           //定义一个自定义类MyComparator的对象
           Comparator cmp = new MyComparator();
           Arrays.sort(a, cmp);
           for(int i = 0; i < a.length; i ++) {
               System.out.print(a[i] + " ");
               }
       }
   
       //Comparator是一个接口，所以这里我们自己定义的类MyComparator要		implents该接口
       //而不是extends Comparator
       static class MyComparator implements Comparator<Integer> {
           @Override
           public int compare(Integer o1, Integer o2) {
               //如果n1小于n2，我们就返回正值，如果n1大于n2我们就返回负			值，
               //这样颠倒一下，就可以实现反向排序了
               if(o1 < o2) {
                   return 1;
               }
               else if(o1 > o2) {
                   return -1;
                   }
               else
                   {
                   return 0;
                       }
               }
           }
   }
   ```

   ```java
         	// 或者更骚的一种方法，使用匿名函数
   		// 这里是先最后的索引，然后再前面的索引
   		Arrays.sort(events,(i1,i2)->
           {
               if(i1[1]!=i2[1])return i1[1]-i2[1];
               return i1[0]-i2[0];
           });
   ```

# 3.笔试题目

## Leetcode - 445 无重叠区间

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

- 可以认为区间的终点总是大于它的起点。
- 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:

> 输入: [ [1,2], [2,3], [3,4], [1,3] ]
>
> 输出: 1
>
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:

> 输入: [ [1,2], [1,2], [1,2] ]
>
> 输出: 2
>
> 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:

> 输入: [ [1,2], [2,3] ]
>
> 输出: 0
>
> 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
>

```java
/**
1.首先进行排序，多级排序
2.之后再根据结束时间，从高到低，贪心搜索
3.需要注意的是，需要不断更新开始的值，舍弃掉开始时间较早的值，因为它们占用范围更大。
*/

class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (i,j)->{
            if(i[1]!=j[1])
                return j[1] - i[1];
            else 
                return j[0] - i[0];
            });
        for(int[] item:intervals){
            System.out.print(item[0]);
            System.out.println(item[1]);
        }

        int[] prio = intervals[0];
        int num = 0;

        for(int index = 1; index < intervals.length; index++){
            if(intervals[index][1] > prio[0]){
                if(prio[0] < intervals[index][0]){
                    prio = intervals[index];
                }
                num++;
                }
            else{
                prio = intervals[index];
            }
        }

        return num;

    }   

}
```

还有另一种贪心的揭发：

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        
        // 这里针对的是每个字段的结束时间进行排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[1] - interval2[1];
            }
        });
		
        // 以结束时间为升序，进行贪心遍历
        int n = intervals.length;
        int right = intervals[0][1];
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (intervals[i][0] >= right) {
                ++ans;
                right = intervals[i][1];
            }
        }
        return n - ans;
    }
}
```

这题也可以用动态规划求解：

```java
// 离谱的是，官方的题解竟然超时了
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        
        // 排序，但并不是多级排序的操作
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[0] - interval2[0];
            }
        });

        int n = intervals.length;
        int[] f = new int[n];
        Arrays.fill(f, 1);
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (intervals[j][1] <= intervals[i][0]) {
                    // 这里把max去掉直接用f[j]+1貌似也能跑，但是超时了
                    // 不知道对不对
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        return n - Arrays.stream(f).max().getAsInt();
    }
}

```

# 4.笔试题目类型

## 4.1 岛屿数量问题

解决方法

- 并查集
- DFS
- BFS

## 4.2 最短路径问题

解决最短路径常规的方法有哪些？

- ### 迪杰斯特算法

- ### 弗洛伊德算法

- ### DFS BFS

## 4.3 多重排序问题（开会问题）

- 多级排序，开始时间，结束时间排序，之后再贪心策略，或者动态规划来解决

## 4.4 图中是否存在路径问题

## 4.5 二分查找问题

- 查找的内容在数组中存在
- 查找的内容在数组中不存在

## 4.6 回文子串问题
